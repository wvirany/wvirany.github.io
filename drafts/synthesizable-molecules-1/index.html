<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="http://localhost:1313//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    Generating Synthesizable Molecules (1/2) | Walter Virany
    
</title>

<link rel="canonical" href="http://localhost:1313/drafts/synthesizable-molecules-1/"/>












<link rel="stylesheet" href="/assets/combined.min.c5b19f349890ba8c8308e8d948f1754211fca49303531d62bb79927877c7df0e.css" media="all">





  </head>

  

  
  
  

  <body class="light">

    <div class="content">
      <header>
        

<div class="header">

    

    <h1 class="header-title">Walter Virany</h1>
    
    
    

    <div class="flex">
        

        
        
      
        <p class="small ">
            <a href="/" >
                /blog
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/me" >
                /me
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/why" >
                /why?
            </a>
        </p>
        
        
    </div>

    

</div>

      </header>

      <main class="main">
        







<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">Generating Synthesizable Molecules (1/2)</h1>
    
    <p class="single-summary">Part 1: Projecting Molecules into Synthesizable Chemical Spaces</p>
    

    

    <p class="single-readtime">
      

      
      &nbsp; · &nbsp;
      9 min read
      
    </p>

  </div>

  

  

  

  

  <div class="single-content">
    <hr>
<p>TODO:</p>
<ul>
<li><input disabled="" type="checkbox"> Replace package imports at end with only what is needed</li>
<li><input checked="" disabled="" type="checkbox"> Molecules as bits</li>
<li>[] Defining chemical space</li>
<li>[] Postfix notation</li>
<li>[] Transformer model</li>
</ul>
<hr>
<p>A significant challenge in the use of generative modeling for molecular design is the problem of synthesizability. That is, a fancy deep learning model might make a molecule that checks all of our boxes in terms of desirable properties, but can it actually be synthesized in a lab? If the answer is no, then that <em>in silico</em> molecule is not very useful.</p>
<p>There are many attempts to overcome this problem, but one elegant approach is the work of <a href="https://arxiv.org/pdf/2406.04628">Luo et al. [2024]</a>, in which they &ldquo;project&rdquo; molecules into synthesizable chemical space.
This effectively boils down to a machine translationt task, in which a generated molecule is translated via a transformer architecture to its closest synthesizable relative.</p>
<p>In this blog post, I aim to review the work of <a href="https://arxiv.org/pdf/2406.04628">Luo et al. [2024]</a>. The first ~half is essentially a tutorial on implementing their work. The second half explores experiments?</p>
<p>something something lightweight / simple tutorial for demonstration and reproducibility?</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>First, let&rsquo;s import the necessary packages that we use:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">import</span> torch
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> torch.nn <span style="color:#00f">as</span> nn
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> torch.nn.functional <span style="color:#00f">as</span> F
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> rdkit <span style="color:#00f">import</span> Chem
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> rdkit.Chem <span style="color:#00f">import</span> AllChem, rdChemReactions
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">from</span> typing <span style="color:#00f">import</span> List, Dict, Union
</span></span></code></pre></div><h3 id="molecules-as-bits">Molecules as Bits</h3>
<p>We ultimately want to “featurize” molecules, i.e., we want to encode them in a format suitable for input to a transformer model.
We&rsquo;ll do so by representing a molecule as a graph.
Thus, we store the nodes (atoms) in a list, and the edges between nodes (bonds) in an adjacency matrix.</p>
<p>First, it will be useful to define the following <code>Molecule</code> class, a simple wrapper around the RDKit molecule object:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">Molecule</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, smiles: str):
</span></span><span style="display:flex;"><span>        self.smiles = smiles
</span></span><span style="display:flex;"><span>        self._rdmol = Chem.MolFromSmiles(smiles)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @property
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> rdmol(self):
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> self._rdmol
</span></span></code></pre></div><p>We can start by defining a simple molecule, ethanol:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#008000"># Create a molecule</span>
</span></span><span style="display:flex;"><span>ethanol = Molecule(<span style="color:#a31515">&#34;CCO&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mol = ethanol.rdmol
</span></span></code></pre></div><p>Let&rsquo;s also visualize the molecule:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#008000"># Show carbons in molecule</span>
</span></span><span style="display:flex;"><span>Chem.AllChem.Compute2DCoords(mol)
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> atom <span style="color:#00f">in</span> mol.GetAtoms():
</span></span><span style="display:flex;"><span>    atom.SetProp(<span style="color:#a31515">&#39;atomLabel&#39;</span>, atom.GetSymbol())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>img = Draw.MolToImage(mol, size=(300, 300))
</span></span><span style="display:flex;"><span>display(img)
</span></span></code></pre></div><div id="fig1" class="figure">
  <img src="figures/ethanol.png" alt="Unscaled Healthy" style="width:40%; margin-left: auto; margin-right:auto">
</div>
<p>Next, we&rsquo;ll represent atoms by their atomic number:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>num_atoms = mol.GetNumAtoms()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Atom features</span>
</span></span><span style="display:flex;"><span>atoms = torch.zeros(num_atoms, dtype=torch.float32)
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(num_atoms):
</span></span><span style="display:flex;"><span>    atom = mol.GetAtomWithIdx(i)    <span style="color:#008000"># Gets atom object</span>
</span></span><span style="display:flex;"><span>    atoms[i] = atom.GetAtomicNum()  <span style="color:#008000"># Gets corresponding atomic number</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atoms
</span></span></code></pre></div><pre tabindex="0"><code>tensor([6., 6., 8.])
</code></pre><p>And we&rsquo;ll store bonds as their bond types in an adjacency matrix. This effectively captures information regarding which atoms in the molecule are bonded, and what type of bond they share (e.g., single, double, etc.):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#008000"># Bond features</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Bond features: create adjacency matrix with bond types</span>
</span></span><span style="display:flex;"><span>bonds = torch.zeros((num_atoms, num_atoms), dtype=torch.long)
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> bond <span style="color:#00f">in</span> mol.GetBonds():
</span></span><span style="display:flex;"><span>    i = bond.GetBeginAtomIdx()              <span style="color:#008000"># Get first atom in bond</span>
</span></span><span style="display:flex;"><span>    j = bond.GetEndAtomIdx()                <span style="color:#008000"># Get second atom in bond</span>
</span></span><span style="display:flex;"><span>    bond_type = bond.GetBondTypeAsDouble()  <span style="color:#008000"># Get bond type</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Graph is undirected, so atom i and j both have the same mutual bond</span>
</span></span><span style="display:flex;"><span>    bonds[i, j] = bond_type
</span></span><span style="display:flex;"><span>    bonds[j, i] = bond_type
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bonds
</span></span></code></pre></div><pre tabindex="0"><code>tensor([[0, 1, 0],
        [1, 0, 1],
        [0, 1, 0]])
</code></pre><h3 id="defining-chemical-space">Defining Chemical Space</h3>
<p>We define a chemical space $\mathcal{C}$ as a set of molecules generated by a starting set of building block molecules, denoted</p>
<p>$$
\mathcal{B} = \{B_1, B_2, \dots, B_N\},
$$</p>
<p>and a set of reaction rules, denoted</p>
<p>$$
\mathcal{R} = \{R_1, R_2, \dots, R_M\}.
$$</p>
<p>A reaction rule can be formalized as a function which maps a set of reactants to a set of reaction products.
For example, a reaction rule $R$ which takes two reactants can be written as</p>
<p>$$
\begin{align*}
R: \mathcal{X_1} \times \mathcal{X_2} &amp;\to \mathcal{C}\\
(X_1, X_2) &amp;\mapsto Y.
\end{align*}
$$</p>
<p>Here, $\mathcal{X_1}$ and $\mathcal{X_2}$ are sets of molecules to which reaction $R$ can be applied, and $Y$ is the main reaction product<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. $\mathcal{C}$ is then constructed by applying each of the reactions in $\mathcal{R}$ iteratively to every possible combination of molecules in $\mathcal{B}$.</p>
<p>Let&rsquo;s implement this.
We start by defining <code>Molecule</code> and <code>Reaction</code> classes:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">Molecule</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, smiles: str):
</span></span><span style="display:flex;"><span>        self.smiles = smiles
</span></span><span style="display:flex;"><span>        self._rdmol = Chem.MolFromSmiles(smiles)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @property
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> rdmol(self):
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> self._rdmol
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">Reaction</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, smarts: str):
</span></span><span style="display:flex;"><span>        self.smarts = smarts
</span></span><span style="display:flex;"><span>        self._reaction = AllChem.ReactionFromSmarts(smarts)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Need to initialize the reaction</span>
</span></span><span style="display:flex;"><span>        rdChemReactions.ChemicalReaction.Initialize(self._reaction)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> apply(self, reactants: List[Molecule]) -&gt; List[Molecule]:
</span></span><span style="display:flex;"><span>        reactant_mols = [r.rdmol <span style="color:#00f">for</span> r <span style="color:#00f">in</span> reactants]
</span></span><span style="display:flex;"><span>        products = self._reaction.RunReactants(reactant_mols)
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> products:
</span></span><span style="display:flex;"><span>            <span style="color:#008000"># Return main product</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> [[Molecule(Chem.MolToSmiles(p)) <span style="color:#00f">for</span> p <span style="color:#00f">in</span> products[0]][0]]
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> can_apply(self, molecules: List[Molecule]) -&gt; bool:
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> len(molecules) != self.num_reactants:
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> <span style="color:#00f">False</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> any(self._reaction.RunReactants([m.rdmol] <span style="color:#00f">for</span> m <span style="color:#00f">in</span> molecules))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @property
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> num_reactants(self) -&gt; int:
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> self._reaction.GetNumReactantTemplates()
</span></span></code></pre></div><p>Let&rsquo;s also define the <code>ChemicalSpace</code> class<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">ChemicalSpace</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, building_blocks: List[Molecule], reactions: List[Reaction]):
</span></span><span style="display:flex;"><span>        self.building_blocks = building_blocks
</span></span><span style="display:flex;"><span>        self.reactions = reactions
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Possible reactions for each molecule are stored as a list of indices in a dictionary</span>
</span></span><span style="display:flex;"><span>        self.reaction_index: Dict[str, List[int]] = self._build_reaction_index()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> _build_reaction_index(self) -&gt; Dict[str, List[int]]:
</span></span><span style="display:flex;"><span>        index = {}
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># For each molecule, get the indices of the reactions which can be applied to it</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> mol <span style="color:#00f">in</span> self.building_blocks:
</span></span><span style="display:flex;"><span>            applicable_reactions = [j <span style="color:#00f">for</span> j, r <span style="color:#00f">in</span> enumerate(self.reactions) <span style="color:#00f">if</span> r.can_apply([mol])]
</span></span><span style="display:flex;"><span>            index[mol.smiles] = applicable_reactions
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> index
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> get_applicable_reactions(self, mol: Molecule) -&gt; List[Reaction]:
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Get list of reaction indices for given molecule</span>
</span></span><span style="display:flex;"><span>        indices = self.reaction_index.get(mol.smiles, [])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Return the reactions specified by the given indices</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> [self.reactions[i] <span style="color:#00f">for</span> i <span style="color:#00f">in</span> indices] 
</span></span></code></pre></div><h3 id="postfix-notation-of-synthesis">Postfix Notation of Synthesis</h3>
<p>For a guide to reactions in RDKit, I recommend these:</p>
<ol>
<li><a href="https://github.com/rdkit/rdkit-tutorials/blob/master/notebooks/003_SMARTS_ReactionsExamples.ipynb">https://github.com/rdkit/rdkit-tutorials/blob/master/notebooks/003_SMARTS_ReactionsExamples.ipynb</a></li>
<li><a href="https://www.rdkit.org/docs/GettingStartedInPython.html#chemical-reactions">https://www.rdkit.org/docs/GettingStartedInPython.html#chemical-reactions</a></li>
</ol>
<h3 id="representing-molecules-as-graphs">Representing Molecules as Graphs</h3>
<p>The transformer architecture which we will develop later encodes molecular graph representations.
Here, I show a simple example of how we represent molecules as graphs.</p>
<p>First, let&rsquo;s create a simple molecule; ethanol:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#008000"># Create a molecule</span>
</span></span><span style="display:flex;"><span>ethanol = Molecule(<span style="color:#a31515">&#34;CCO&#34;</span>)
</span></span></code></pre></div><p>We ultimately want to &ldquo;featurize&rdquo; the molecule.
That is, we want to represent the molecule in a format suitable to be input to our transformer.
For this simple example, we represent atoms as their atomic number. Similarly, we featurize the bonds by creating an adjacency matrix which defines each atom in the molecule is related.
For example, the element in row $i$ and column $j$ indicates the type of bond between atoms $i$ and $j$ in the molecule.</p>
<p>We can access the RDKit molecule object via the <code>rdmol</code> attribute we defined earlier.
This object comes equipped with a suite of functionality from the RDKit package.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>mol = ethanol.rdmol
</span></span><span style="display:flex;"><span>num_atoms = mol.GetNumAtoms()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Atom features</span>
</span></span><span style="display:flex;"><span>atoms = torch.zeros(num_atoms, dtype=torch.float32)
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(num_atoms):
</span></span><span style="display:flex;"><span>    atom = mol.GetAtomWithIdx(i)
</span></span><span style="display:flex;"><span>    atoms[i] = atom.GetAtomicNum()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Bond features</span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># 0: no bond, 1: single bond, 1.5: aromatic bond, 2: double bond</span>
</span></span><span style="display:flex;"><span>bonds = torch.zeros((num_atoms))
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> bond <span style="color:#00f">in</span> mol.GetBonds():
</span></span><span style="display:flex;"><span>    i = bond.GetBeginAtomIdx()
</span></span><span style="display:flex;"><span>    j = bond.GetEndAtomIdx()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000"># Convert bond types to integers</span>
</span></span><span style="display:flex;"><span>    bond_type = mol.GetBondType()
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> bond_type == Chem.rdchem.BondType.SINGLE:
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> 1
</span></span><span style="display:flex;"><span>    <span style="color:#00f">elif</span> bond_type == Chem.rdchem.BondType.DOUBLE:
</span></span><span style="display:flex;"><span>        bond_type = 2
</span></span><span style="display:flex;"><span>    <span style="color:#00f">elif</span> bond.GetBondType() == Chem.rdchem.BondType.TRIPLE:
</span></span><span style="display:flex;"><span>        bond_type = 3
</span></span><span style="display:flex;"><span>    <span style="color:#00f">elif</span> bond.GetBondType() == Chem.rdchem.BondType.AROMATIC:
</span></span><span style="display:flex;"><span>        bond_type = 4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    bonds[i, j] = bond_type
</span></span><span style="display:flex;"><span>    bonds[j, i] = bond_type
</span></span></code></pre></div><p>Now, the information describing the atoms and bonds in the molecule are stored as tensors:</p>
<pre tabindex="0"><code>Atoms tensor:
tensor([6, 6, 8])  # C, C, O

Bonds matrix:
tensor([[0, 1, 0],   # single bond between C-O
        [1, 0, 1],   # single bonds between C-O and O-O
        [0, 1, 0]])  # single bond between O-O
</code></pre><h2 id="building-the-model">Building the Model</h2>
<p>The model consists of two main components:</p>
<h3 id="a-simple-graph-encoder">A Simple Graph Encoder</h3>
<p>First, we build a simple graph encoder network to see how the model processes the molecular graph representations.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">EmbeddingLayer</span>(nn.Module):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, num_atom_classes=100, num_bond_classes=5, dim=8):
</span></span><span style="display:flex;"><span>        super().__init__()
</span></span><span style="display:flex;"><span>        self.atom_emb = nn.Embedding(num_atom_classes, dim, padding_idx=0)
</span></span><span style="display:flex;"><span>        self.bond_emb = nn.Embedding(num_bond_classes, dim, padding_idx=0)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> forward(self, atoms, bonds):
</span></span><span style="display:flex;"><span>        node_features = self.atom_emb(atoms)
</span></span><span style="display:flex;"><span>        edge_features = self.bond_emb(bonds)
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> node_features, bond_features
</span></span></code></pre></div><p>So far, this shows how we pass molecular graphs through the embedding layer. Let&rsquo;s explore how this works:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#008000"># Create embedding layer</span>
</span></span><span style="display:flex;"><span>embed = EmbeddingLayer()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atoms = torch.tensor([6, 6, 8])  <span style="color:#008000"># C, C, O</span>
</span></span><span style="display:flex;"><span>bonds = torch.tensor([[0, 1, 0],
</span></span><span style="display:flex;"><span>                     [1, 0, 1],
</span></span><span style="display:flex;"><span>                     [0, 1, 0]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000"># Get embeddings</span>
</span></span><span style="display:flex;"><span>node_features, edge_features = embed(atoms, bonds)
</span></span></code></pre></div><p>Now, the input has been transformed into the initial embeddings, replacing each of the atomic and bond features with 8-dimensional vectors:</p>
<pre tabindex="0"><code>Atom embeddings shape: torch.Size([3, 8])
Bond embeddings shape: torch.Size([3, 3, 8])
</code></pre><p>We see that the shape of the atom embeddings tensor is (3, 8), indicating that there are 3 atoms in the molecule, each with an 8-dimensional embedding vector describing the type of atom.
Similarly, the shape of the bond embeddings tensor is (3, 3, 8), now indicating that each element of the 3 $\times$ 3 adjacency matrix is likewise an 8-dimensional vector.</p>
<p>Now, all we&rsquo;ve done so far is passed the molecules through the embedding layer.
Next, we build the transformer.
This will involve passing the embedded input through a sequence of several encoding layers.
Let&rsquo;s see how this encoder layer works <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">EncoderLayer</span>(nn.Module):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, d_model=64, nhead=8):
</span></span><span style="display:flex;"><span>        super().__init__()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Multi-head self attention</span>
</span></span><span style="display:flex;"><span>        self.self_attn = nn.MultiheadAttention(
</span></span><span style="display:flex;"><span>            embed_dim=d_model,
</span></span><span style="display:flex;"><span>            num_heads=nhead,
</span></span><span style="display:flex;"><span>            batch_first=<span style="color:#00f">True</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Feed Forward Network</span>
</span></span><span style="display:flex;"><span>        self.linear1 = nn.Linear(d_model, d_model*4)
</span></span><span style="display:flex;"><span>        self.linear2 = nn.Linear(d_model*4, d_model)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Layer Normalization</span>
</span></span><span style="display:flex;"><span>        self.norm1 = nn.LayerNorm(d_model)
</span></span><span style="display:flex;"><span>        self.norm2 = nn.LayerNorm(d_model)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> forward(self, x, padding_mask=<span style="color:#00f">None</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Self Attention Block</span>
</span></span><span style="display:flex;"><span>        attn_out, _ = self.self_attn(x, x, x, key_padding_mask=padding_mask)
</span></span><span style="display:flex;"><span>        x = x + attn_out
</span></span><span style="display:flex;"><span>        x = self.norm1(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Feed Forward Block</span>
</span></span><span style="display:flex;"><span>        ff_out = self.linear2(F.relu(self.linear(x)))
</span></span><span style="display:flex;"><span>        x = x + ff_out
</span></span><span style="display:flex;"><span>        x = self.norm2(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> x
</span></span></code></pre></div><p>This is just a conventional encoder layer as defined in <a href="https://arxiv.org/pdf/1706.03762">Vaswani et al., [2017]</a>, with a multi-head self-attention mechanism, followed by an MLP, with layer normalization and residual connections in between. This just takes our embedding vectors as input, and returns vectors of the same shape:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>d_model = 8
</span></span><span style="display:flex;"><span>encoder_layer = EncoderLayer(d_model=d_model, nhead=2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>output = layer(atoms)
</span></span></code></pre></div><p>Here, we used the <code>atoms</code> tensor from the previous example. Now, the output is the same shape as the original embedded representation:</p>
<pre tabindex="0"><code>Output shape: torch.Size([3, 8])
</code></pre><p>All that&rsquo;s left is to stack these encoder layers in a sequence.
We put this together in the following <code>GraphEncoder</code> class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">GraphEncoder</span>(nn.Module):
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> __init__(self, num_atom_classes=100, num_bond_classes=5, dim=8, n_layers=2, n_heads=2):
</span></span><span style="display:flex;"><span>        super().__init__()
</span></span><span style="display:flex;"><span>        self.atom_emb = nn.Embedding(num_atom_classes, dim, padding_idx=0)
</span></span><span style="display:flex;"><span>        self.bond_emb = nn.Embedding(num_bond_classes, dim, padding_idx=0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Add transformer layers</span>
</span></span><span style="display:flex;"><span>        encoder_layer = nn.TransformerEncoderLayer(
</span></span><span style="display:flex;"><span>            d_model=dim,
</span></span><span style="display:flex;"><span>            nhead=n_heads,
</span></span><span style="display:flex;"><span>            batch_first=<span style="color:#00f">True</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Stack encoder layers in sequence</span>
</span></span><span style="display:flex;"><span>        self.transformer = nn.TransformerEncoder(
</span></span><span style="display:flex;"><span>            encoder_layer,
</span></span><span style="display:flex;"><span>            num_layers=n_layers
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">def</span> forward(self, atoms, bonds, padding_mask=<span style="color:#00f">None</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Get Embeddings</span>
</span></span><span style="display:flex;"><span>        node_features = self.atom_emb(atoms)    <span style="color:#008000"># (num_atoms, dim)</span>
</span></span><span style="display:flex;"><span>        edge_features = self.bond_emb(bonds)    <span style="color:#008000"># (num_atoms, num_atoms, dim)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Combine atom and bond information</span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># For each atom, aggregate bond information from its neighbors</span>
</span></span><span style="display:flex;"><span>        edge_sum = edge_features.sum(dim=1)     <span style="color:#008000"># (num_atoms, dim)</span>
</span></span><span style="display:flex;"><span>        node_features = node_features + edge_sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000"># Pass through transformer</span>
</span></span><span style="display:flex;"><span>        out = self.transformer(
</span></span><span style="display:flex;"><span>            node_features,
</span></span><span style="display:flex;"><span>            src_key_padding_mask=padding_mask
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> out
</span></span></code></pre></div><p>Again, let&rsquo;s see how to use this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>encoder = GraphEncoder()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atoms = torch.tensor([6, 6, 8])  <span style="color:#008000"># C, C, O</span>
</span></span><span style="display:flex;"><span>bonds = torch.tensor([[0, 1, 0],
</span></span><span style="display:flex;"><span>                      [1, 0, 1],
</span></span><span style="display:flex;"><span>                      [0, 1, 0]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>encoded = encoder(atoms, bonds)
</span></span></code></pre></div><p>Our output takes the shape:</p>
<pre tabindex="0"><code>Encoded molecule shape: torch.Size([3, 8])
</code></pre><h3 id="postfix-notation-decoder">Postfix Notation Decoder</h3>
<h3 id="training">Training</h3>
<h3 id="references-and-further-reading">References and Further Reading</h3>
<ol>
<li>Shitong Luo, Wenhao Gao, Zuofan Wu, Jian Peng, Connor W. Coley, and Jianzhu Ma. Projecting molecules into
synthesizable chemical spaces. In Forty-first International Conference on Machine Learning, 2024.</li>
</ol>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>It is sometimes the case that a reaction has multiple main reaction products. For the sake of clarity in our discussion, I am assuming there is only one main reaction product. However, the original authors&rsquo; implementation handles the more general case.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>We use reaction list, they use reaction matrix.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>After the initial embeddings, the original paper takes &ldquo;edges into account by adding a bond type-dependent learnable bias term to the query-key product matrix&rdquo;.
We&rsquo;ll simplify this detail; instead by accounting for bond information by simply adding the <code>node_features</code> and <code>edge_features</code> embeddings together.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    
  </div>

  

  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      
<style>
  .katex a {
    text-decoration: none;
    color: inherit;
  }
  .katex a:hover {
    text-decoration: none;
  }
</style>

<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ],
      trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
      macros: {
        "\\eqref": "\\href{###1}{\\text{#1}}",
        "\\ref": "\\href{###1}{\\text{#1}}",
        "\\label": "\\htmlId{#1}{}",
        "\\R": "\\mathbb{R}",
        "\\bR": "\\mathbf{R}",
        "\\C": "\\mathbb{C}",
        "\\Z": "\\mathbb{Z}",
        "\\N": "\\mathbb{N}",
        "\\Q": "\\mathbb{Q}",
        "\\E": "\\mathbb{E}",
        "\\cD": "\\mathcal{D}",
        "\\var": "\\operatorname{Var}",
        "\\cov":"\\operatorname{cov}",
        "\\x": "\\mathbf{x}",
        "\\X": "\\mathbf{X}",
        "\\w": "\\mathbf{w}",
        "\\W": "\\mathbf{W}",
        "\\y": "\\mathbf{y}",
        "\\z": "\\mathbf{z}",
        "\\Z": "\\mathbf{Z}",
        "\\u": "\\mathbf{u}",
        "\\U": "\\mathbf{U}",
        "\\V": "\\mathbf{V}",
        "\\I": "\\mathbf{I}",
        "\\A": "\\mathbf{A}",
        "\\a": "\\mathbf{a}",
        "\\B": "\\mathbf{B}",
        "\\b": "\\mathbf{b}",
        "\\c": "\\mathbf{c}",
        "\\D": "\\mathbf{D}",
        "\\M": "\\mathbf{M}",
        "\\m": "\\mathbf{m}",
        "\\bC": "\\mathbf{C}",
        "\\J": "\\mathbf{J}",
        "\\K": "\\mathbf{K}",
        "\\L": "\\mathbf{L}",
        "\\bS": "\\mathbf{S}",
        "\\bmu": "\\boldsymbol{\\mu}",
        "\\bphi": "\\boldsymbol{\\phi}",
        "\\bepsilon": "\\boldsymbol{\\epsilon}",
        "\\bSigma": "\\boldsymbol{\\Sigma}",
        "\\bLambda": "\\boldsymbol{\\Lambda}",
        "\\bPhi": "\\boldsymbol{\\Phi}",
        "\\zero": "\\mathbf{0}",
        "\\one": "\\mathbf{1}",
        "\\T": "^{\\top}",
        "\\p": "^\\prime",
        "\\inv": "^{-1}",
        "\\ij": "_{ij}",
        "\\Norm": "\\mathcal{N}",
        "\\gam": "\\text{Gamma}",
        "\\nll": "\\text{NLL}",
        "\\argmin": "\\underset{#1}{\\operatorname{argmin}}",
        "\\argmax": "\\underset{#1}{\\operatorname{argmax}}",
        "\\diag": "\\operatorname{diag}",
        "\\tr": "\\operatorname{tr}",
        "\\pbmu": "\\frac{\\partial}{\\partial \\boldsymbol{\\mu}}",
        "\\pSigma": "\\frac{\\partial}{\\partial \\Sigma}",
        "\\pbx": "\\frac{\\partial}{\\partial \\mathbf{x}}",
        "\\px": "\\frac{\\partial}{\\partial x}",
        "\\pbA": "\\frac{\\partial}{\\partial \\mathbf{A}}",
        "\\ml": "_\\text{ML}",
      }
    });
  });
</script>

    </footer>

  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>


<script>
  
  function updateFigureNumbers() {

      const figRefs = document.querySelectorAll('.fig-ref');
      figRefs.forEach(ref => {
          const figId = ref.getAttribute('href').slice(1);
          const figElement = document.getElementById(figId);
          if (figElement) {
              const figIndex = Array.from(figures).indexOf(figElement) + 1;
              ref.textContent = `Figure ${figIndex}`;
          }
      });
  }

  
  window.addEventListener('load', updateFigureNumbers);
</script>



</html>